<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Analyses multivariées, Partie 1</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/spacelab.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>
<link href="libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="libs/highlightjs-9.12.0/highlight.js"></script>
<script src="libs/htmlwidgets-1.3/htmlwidgets.js"></script>
<script src="libs/plotly-binding-4.8.0/plotly.js"></script>
<script src="libs/typedarray-0.1/typedarray.min.js"></script>
<link href="libs/crosstalk-1.0.0/css/crosstalk.css" rel="stylesheet" />
<script src="libs/crosstalk-1.0.0/js/crosstalk.min.js"></script>
<link href="libs/plotly-htmlwidgets-css-1.39.2/plotly-htmlwidgets.css" rel="stylesheet" />
<script src="libs/plotly-main-1.39.2/plotly-latest.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Analyses multivariées, Partie 1</h1>
<h4 class="date"><br/>2 décembre 2019</h4>

</div>


<div id="objectifs" class="section level1">
<h1>Objectifs</h1>
<ul>
<li><p>Décrire différents rôles des techniques d’analyse multivariées.</p></li>
<li><p>Décrire l’utilité des méthodes d’ordination et de regroupement pour réduire la dimensionalité d’un jeu de données.</p></li>
<li><p>Exécuter une analyse en composantes principales (<em>principal component analysis</em>) et pouvoir interpréter les résultats.</p></li>
<li><p>Diviser les observations en classes à partir des méthodes de regroupement hiérarchique (<em>hierarchical clustering</em>).</p></li>
</ul>
</div>
<div id="pourquoi-les-analyses-multivariees" class="section level1">
<h1>Pourquoi les analyses multivariées?</h1>
<p>Les analyses multivariées visent à modéliser la <em>distribution conjointe</em> de plusieurs variables, c’est-à-dire la variation des variables prises individuellement et les corrélations entre elles.</p>
<p>Voici certaines situations où ces méthodes pourraient être utiles:</p>
<ul>
<li><p>Au moment de décrire et d’explorer un jeu de données avec plusieurs variables, il peut être intéressant de visualiser la relation entre les variables (ex.: corrélations) et entre les observations (ex.: similarité entre nos sites d’études) dans un seul graphique.</p></li>
<li><p>La réponse qu’on souhaite expliquer est multivariée. Par exemple, la composition d’une communauté écologique est définie comme la présence ou l’abondance de plusieurs espèces à différents sites. Les interactions entre espèces (ex.: compétition) font qu’on ne peut pas étudier cette réponse comme la combinaison de plusieurs réponses univariées indépendantes (une espèce à la fois).</p></li>
<li><p>On veut expliquer une réponse univariée en fonction d’un grand nombre de prédicteurs qui sont partiellement corrélés. Par exemple, la présence d’une espèce en fonction des conditions climatiques, la croissance d’arbres de différentes espèces sur un site en fonction de leurs traits fonctionnels, etc. Dans les cours précédents sur la régression, nous avons vu qu’il est difficile d’estimer l’effet d’un grand nombre de prédicteurs potentiellement corrélés dans un même modèle. La sélection de modèles est aussi compliquée lorsque le nombre de prédicteurs est grand.</p></li>
</ul>
</div>
<div id="structure-des-donnees-multivariees" class="section level1">
<h1>Structure des données multivariées</h1>
<p>Supposons que nous réalisons <span class="math inline">\(n\)</span> observations de <span class="math inline">\(p\)</span> variables. Nous représentons ces observations par une matrice où <span class="math inline">\(x_{ij}\)</span> est la valeur de la variable <span class="math inline">\(j\)</span> pour l’observation <span class="math inline">\(i\)</span>:</p>
<p><span class="math display">\[  
\begin{bmatrix}
x_{11} &amp; x_{12} &amp; ... &amp; x_{1p} \\
x_{21} &amp; x_{22} &amp; ... &amp; x_{2p} \\
... &amp; ... &amp; ... &amp; ... \\
x_{n1} &amp; ... &amp; ... &amp; x_{np}
\end{bmatrix}
\]</span></p>
<p>Par exemple, prenons le tableau de données <a href="../donnees/cities_climate.csv">cities_climate.csv</a>, qui contient des données climatiques tirées de WorldClim pour 49 grandes villes.</p>
<pre class="r"><code>villes &lt;- read.csv(&quot;../donnees/cities_climate.csv&quot;)
head(villes)</code></pre>
<pre><code>##       city    long    lat t_mean t_diu  t_sd t_max t_min p_ann p_max p_min
## 1    Tokyo 139.751 35.685   15.6   7.9 7.492  30.7   0.7  1428   185    47
## 2 Shanghai 121.400 31.046   16.2   7.4 8.339  31.6   0.8  1050   167    41
## 3   Mumbai  72.826 18.975   26.8   7.3 1.767  32.7  18.9  2370   827     0
## 4  Karachi  67.082 24.906   25.9   9.9 4.035  34.2  12.0   194    82     0
## 5    Delhi  77.217 28.667   25.1  13.1 6.715  40.5   7.3   734   274     3
## 6   Manila 120.982 14.604   27.3   8.0 1.078  33.8  21.4  2150   466     8
##   p_cv
## 1   40
## 2   46
## 3  143
## 4  134
## 5  142
## 6   90</code></pre>
<p>Voici la liste des variables climatiques de ce tableau de données:</p>
<ul>
<li><em>t_mean</em>: Température moyenne annuelle.</li>
<li><em>t_diu</em>: Variation journalière de température, différence moyenne entre la température maximale et minimale dans un même mois.</li>
<li><em>t_sd</em>: Variation saisonnière de température, écart-type de la température moyenne entre les mois.</li>
<li><em>t_max</em>: Température maximale du mois le plus chaud.</li>
<li><em>t_min</em>: Température minimale du mois le plus froid.</li>
<li><em>p_ann</em>: Précipitation annuelle.</li>
<li><em>p_max</em>: Précipitation du mois le plus humide.</li>
<li><em>p_min</em>: Précipitation du mois le plus sec.</li>
<li><em>p_cv</em>: Coefficient de variation (ratio écart-type / moyenne) de la précipitation entre les mois.</li>
</ul>
<p>Toutes les températures sont en degrés C et toutes les variables de précipitation (sauf le coefficient de variation) sont en mm.</p>
<p>Nous allons extraire les variables climatiques dans un tableau de données séparé, puis ajouter des noms aux rangées (<code>rownames</code>) pour indiquer le nom des villes.</p>
<pre class="r"><code>climat &lt;- villes[, 4:12]
rownames(climat) &lt;- villes$city</code></pre>
<p>Dans un contexte d’analyse multivariée, nous traiterons nos 49 observations comme des “points” dans un espace à 9 dimensions (une dimension pour chaque variable).</p>
<div id="normalisation-des-donnees" class="section level2">
<h2>Normalisation des données</h2>
<p>Les méthodes d’ordination et de regroupement que nous verrons dans ce cours sont basées sur le concept de <em>distance</em> entre les points dans cet espace multidimensionnel. Toutefois, nous ne pouvons calculer ces distances si les unités diffèrent entre les variables: par exemple, on ne peut pas dire si une variation de température d’un degré C est plus ou moins importante qu’une variation de précipitation d’un mm.</p>
<p>Pour cette raison, nous commençons par normaliser nos données, c’est-à-dire représenter chaque variable sous une forme centrée et réduite. Lorsque appliquée à un tableau de données où toutes les variables sont numériques, la fonction <code>scale</code> transforme chaque variable en soustrayant sa moyenne et en divisant par son écart-type.</p>
<pre class="r"><code>clim_norm &lt;- scale(climat)
round(head(clim_norm), 2) # Afficher seulement 2 décimales</code></pre>
<pre><code>##          t_mean t_diu  t_sd t_max t_min p_ann p_max p_min  p_cv
## Tokyo     -0.44 -0.77  0.91  0.07 -0.62  0.66 -0.06  0.78 -0.74
## Shanghai  -0.36 -0.96  1.17  0.24 -0.61  0.08 -0.17  0.58 -0.59
## Mumbai     1.17 -1.00 -0.86  0.46  1.14  2.12  3.86 -0.81  1.84
## Karachi    1.04  0.01 -0.16  0.74  0.47 -1.24 -0.69 -0.81  1.62
## Delhi      0.93  1.24  0.67  1.95  0.02 -0.41  0.48 -0.71  1.82
## Manila     1.25 -0.73 -1.07  0.67  1.39  1.78  1.66 -0.54  0.52</code></pre>
<p>Le résultat est une <em>matrice</em> où chaque colonne a une moyenne de 0 et un écart-type de 1. Par exemple, à Tokyo la température moyenne est de 0.44 écart-type sous la moyenne des 49 villes, tandis que la précipitation annuelle est 0.66 écart-type au-dessus de la moyenne des villes.</p>
<p><strong>Note</strong></p>
<p>Vous pouvez vérifier que l’écart-type de chaque colonne est 1 avec la fonction <code>apply</code>:</p>
<pre class="r"><code>apply(clim_norm, 2, sd)</code></pre>
<pre><code>## t_mean  t_diu   t_sd  t_max  t_min  p_ann  p_max  p_min   p_cv 
##      1      1      1      1      1      1      1      1      1</code></pre>
<p>Pour comprendre cette commande, il est plus facile de lire l’instruction à l’envers. La commande <code>apply(clim_norm, 2, sd)</code> dit d’appliquer la fonction écart-type <code>sd</code> à chaque colonne (le chiffre 2 signifie colonne, le chiffre 1 rangée) de la matrice <code>clim_norm</code>.</p>
<p>Il existe des raccourcis dans R pour calculer la somme ou la moyenne des rangées ou des colonnes d’une matrice: <code>rowSums</code>, <code>colSums</code>, <code>rowMeans</code> et <code>colMeans</code>.</p>
</div>
<div id="reduction-de-la-dimensionnalite" class="section level2">
<h2>Réduction de la dimensionnalité</h2>
<p>Il n’est pas possible de visualiser un nuage de points en 9 dimensions. D’un point de vue de l’analyse exploratoire, nous aimerions pouvoir réduire la dimensionnalité de nos données tout en conservant le maximum d’information sur la variation climatique entre les villes. Ce cours vise à offrir une introduction à deux types de méthodes pour effectuer cette réduction</p>
<ul>
<li><p>Les méthodes d’<strong>ordination</strong> effectuent une transformation des <span class="math inline">\(p\)</span> variables originales en un nombre plus restreint de nouvelles variables, de façon à ce que la représentation des points dans l’espace réduit (souvent, en 2 dimensions) reproduise le plus fidèlement possible les distances entre les points dans l’espace original en <span class="math inline">\(p\)</span> dimensions. Ces méthodes ordonnent les observations selon les axes de variation les plus importants, d’où leur nom. L’<strong>analyse en composantes principales</strong> présentée ci-dessous est un exemple de méthode d’ordination.</p></li>
<li><p>Si l’ordination vise à représenter les variables numériques originales par un nombre réduit de variables numériques transformées, les méthodes de <strong>regroupement</strong> (<em>clustering</em>) tentent plutôt de diviser les observations en un nombre discret de groupes (ou catégories) en fonction de leur proximité dans l’espace à <span class="math inline">\(p\)</span> dimensions. La méthode de regroupement vue dans ce cours est la <strong>classification hiérarchique ascendante</strong> (<em>agglomerative hierarchical clustering</em>).</p></li>
</ul>
</div>
</div>
<div id="analyse-en-composantes-principales" class="section level1">
<h1>Analyse en composantes principales</h1>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Voici un nuage de points représentant trois des variables climatiques des 49 villes: la température moyenne, l’écart-type de la température et la précipitation annuelle.</p>
<div id="htmlwidget-a19ba51bcab8f9fd5677" style="width:672px;height:480px;" class="plotly html-widget"></div>
<script type="application/json" data-for="htmlwidget-a19ba51bcab8f9fd5677">{"x":{"visdat":{"19842dcf3e2e":["function () ","plotlyVisDat"]},"cur_data":"19842dcf3e2e","attrs":{"19842dcf3e2e":{"x":{},"y":{},"z":{},"alpha_stroke":1,"sizes":[10,100],"spans":[1,20],"type":"scatter3d","mode":"markers","size":1,"inherit":true},"19842dcf3e2e.1":{"x":{},"y":{},"z":{},"alpha_stroke":1,"sizes":[10,100],"spans":[1,20],"text":{},"type":"scatter3d","mode":"text","size":0.5,"inherit":true}},"layout":{"margin":{"b":40,"l":60,"t":25,"r":10},"scene":{"xaxis":{"title":"t_mean"},"yaxis":{"title":"t_sd"},"zaxis":{"title":"p_ann"}},"hovermode":"closest","showlegend":true},"source":"A","config":{"modeBarButtonsToAdd":[{"name":"Collaborate","icon":{"width":1000,"ascent":500,"descent":-50,"path":"M487 375c7-10 9-23 5-36l-79-259c-3-12-11-23-22-31-11-8-22-12-35-12l-263 0c-15 0-29 5-43 15-13 10-23 23-28 37-5 13-5 25-1 37 0 0 0 3 1 7 1 5 1 8 1 11 0 2 0 4-1 6 0 3-1 5-1 6 1 2 2 4 3 6 1 2 2 4 4 6 2 3 4 5 5 7 5 7 9 16 13 26 4 10 7 19 9 26 0 2 0 5 0 9-1 4-1 6 0 8 0 2 2 5 4 8 3 3 5 5 5 7 4 6 8 15 12 26 4 11 7 19 7 26 1 1 0 4 0 9-1 4-1 7 0 8 1 2 3 5 6 8 4 4 6 6 6 7 4 5 8 13 13 24 4 11 7 20 7 28 1 1 0 4 0 7-1 3-1 6-1 7 0 2 1 4 3 6 1 1 3 4 5 6 2 3 3 5 5 6 1 2 3 5 4 9 2 3 3 7 5 10 1 3 2 6 4 10 2 4 4 7 6 9 2 3 4 5 7 7 3 2 7 3 11 3 3 0 8 0 13-1l0-1c7 2 12 2 14 2l218 0c14 0 25-5 32-16 8-10 10-23 6-37l-79-259c-7-22-13-37-20-43-7-7-19-10-37-10l-248 0c-5 0-9-2-11-5-2-3-2-7 0-12 4-13 18-20 41-20l264 0c5 0 10 2 16 5 5 3 8 6 10 11l85 282c2 5 2 10 2 17 7-3 13-7 17-13z m-304 0c-1-3-1-5 0-7 1-1 3-2 6-2l174 0c2 0 4 1 7 2 2 2 4 4 5 7l6 18c0 3 0 5-1 7-1 1-3 2-6 2l-173 0c-3 0-5-1-8-2-2-2-4-4-4-7z m-24-73c-1-3-1-5 0-7 2-2 3-2 6-2l174 0c2 0 5 0 7 2 3 2 4 4 5 7l6 18c1 2 0 5-1 6-1 2-3 3-5 3l-174 0c-3 0-5-1-7-3-3-1-4-4-5-6z"},"click":"function(gd) { \n        // is this being viewed in RStudio?\n        if (location.search == '?viewer_pane=1') {\n          alert('To learn about plotly for collaboration, visit:\\n https://cpsievert.github.io/plotly_book/plot-ly-for-collaboration.html');\n        } else {\n          window.open('https://cpsievert.github.io/plotly_book/plot-ly-for-collaboration.html', '_blank');\n        }\n      }"}],"cloud":false},"data":[{"x":[15.6,16.2,26.8,25.9,25.1,27.3,4.9,10.9,18.2,14,27,15.8,27.5,12,25.6,21.4,18.8,12.1,11,11.4,25.9,24,23.1,22.7,28,14.7,7.9,27.3,17.6,4.9,18.3,14.8,26.7,17.7,26.8,25.4,27.4,16.6,9,6.5,14.1,12.1,24.4,15.2,18.4,24.7,15.7,25.7,11.3],"y":[7.492,8.339,1.767,4.035,6.715,1.078,9.803,10.167,2.137,6.292,1.09,2.039,0.43,8.775,1.333,5.242,2.659,10.686,4.943,0.324,3.667,7.331,1.969,8.704,1.329,4.373,9.543,1.485,3.668,8.937,3.509,3.768,1.055,3.705,0.446,7.128,0.999,2.941,6.918,10.737,6.672,8.676,2.336,1.139,1.205,2.499,5.805,1.086,5.687],"z":[1428,1050,2370,194,734,2150,679,1420,1388,759,1672,641,1949,1150,1370,20,15,608,627,994,1979,608,1255,159,1457,355,793,2465,1275,636,394,656,1790,411,2363,111,1822,885,574,965,437,330,440,1156,935,461,788,1506,633],"type":"scatter3d","mode":"markers","marker":{"color":"rgba(31,119,180,1)","size":[100],"sizemode":"area","line":{"color":"rgba(31,119,180,1)"}},"textfont":{"size":100},"error_y":{"color":"rgba(31,119,180,1)","width":100},"error_x":{"color":"rgba(31,119,180,1)","width":100},"line":{"color":"rgba(31,119,180,1)","width":100},"frame":null},{"x":[15.6,16.2,26.8,25.9,25.1,27.3,4.9,10.9,18.2,14,27,15.8,27.5,12,25.6,21.4,18.8,12.1,11,11.4,25.9,24,23.1,22.7,28,14.7,7.9,27.3,17.6,4.9,18.3,14.8,26.7,17.7,26.8,25.4,27.4,16.6,9,6.5,14.1,12.1,24.4,15.2,18.4,24.7,15.7,25.7,11.3],"y":[7.492,8.339,1.767,4.035,6.715,1.078,9.803,10.167,2.137,6.292,1.09,2.039,0.43,8.775,1.333,5.242,2.659,10.686,4.943,0.324,3.667,7.331,1.969,8.704,1.329,4.373,9.543,1.485,3.668,8.937,3.509,3.768,1.055,3.705,0.446,7.128,0.999,2.941,6.918,10.737,6.672,8.676,2.336,1.139,1.205,2.499,5.805,1.086,5.687],"z":[1428,1050,2370,194,734,2150,679,1420,1388,759,1672,641,1949,1150,1370,20,15,608,627,994,1979,608,1255,159,1457,355,793,2465,1275,636,394,656,1790,411,2363,111,1822,885,574,965,437,330,440,1156,935,461,788,1506,633],"text":["Tokyo","Shanghai","Mumbai","Karachi","Delhi","Manila","Moscow","Seoul","Sao Paulo","Istanbul","Lagos","Mexico","Jakarta","New York","Kinshasa","Cairo","Lima","Beijing","London","Bogota","Dhaka","Lahore","Rio de Janeiro","Baghdad","Bangkok","Santiago","Toronto","Rangoon","Sydney","Saint Petersburg","Los Angeles","Melbourne","Abidjan","Casablanca","Singapore","Riyadh","Ho Chi Minh City","Cape Town","Berlin","Montreal","Madrid","Kabul","Luanda","Addis Abeba","Nairobi","Dakar","Rome","Santo Domingo","Paris"],"type":"scatter3d","mode":"text","marker":{"color":"rgba(255,127,14,1)","size":[10],"sizemode":"area","line":{"color":"rgba(255,127,14,1)"}},"textfont":{"size":10},"error_y":{"color":"rgba(255,127,14,1)","width":10},"error_x":{"color":"rgba(255,127,14,1)","width":10},"line":{"color":"rgba(255,127,14,1)","width":10},"frame":null}],"highlight":{"on":"plotly_click","persistent":false,"dynamic":false,"selectize":false,"opacityDim":0.2,"selected":{"opacity":1},"debounce":0},"base_url":"https://plot.ly"},"evals":["config.modeBarButtonsToAdd.0.click"],"jsHooks":[]}</script>
<p>La position des points sur l’écran représente la projection du nuage en trois dimensions sur un graphique en deux dimensions. En faisant la rotation du graphique, cette projection change même si la valeur des points demeure la même pour les trois variables. Certaines rotations permettent de mieux différencier les points que d’autres, même si aucune ne reproduit parfaitement les distances entre tous les points. Mathématiquement, ces rotations sont une transformation des variables originales en un nouvel espace en trois dimensions composé de la largeur, de la hauteur et de la profondeur de l’écran; la variation selon cette troisième dimension (profondeur) est bien sûr cachée dans la visualisation.</p>
<p>Considérons le cas extrême où l’on a trois variables <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> et <span class="math inline">\(z\)</span> et qu’une d’entre elles est parfaitement prédite par les deux autres (collinéarité parfaite), par exemple <span class="math inline">\(z = 2x - 5y\)</span>. L’ensemble des points est situé sur un seul plan, mais les axes de ce plan correspondent à une combinaison linéaire des variables originales. Une rotation permettrait d’aligner ce plan avec les deux premières dimensions de la visualisation (largeur et hauteur). Dans ce cas, puisque les données ne varient pas dans la troisième dimension, la projection représente parfaitement la variation des données originales.</p>
<div id="htmlwidget-c3823f98801df8880b3f" style="width:672px;height:480px;" class="plotly html-widget"></div>
<script type="application/json" data-for="htmlwidget-c3823f98801df8880b3f">{"x":{"visdat":{"1984ec6e23":["function () ","plotlyVisDat"]},"cur_data":"1984ec6e23","attrs":{"1984ec6e23":{"x":{},"y":{},"z":{},"alpha_stroke":1,"sizes":[10,100],"spans":[1,20],"type":"scatter3d","mode":"markers","size":1,"inherit":true},"1984ec6e23.1":{"x":{},"y":{},"z":{},"alpha_stroke":1,"sizes":[10,100],"spans":[1,20],"type":"mesh3d","opacity":0.3,"inherit":true}},"layout":{"margin":{"b":40,"l":60,"t":25,"r":10},"scene":{"xaxis":{"title":"x"},"yaxis":{"title":"y"},"zaxis":{"title":"z"}},"hovermode":"closest","showlegend":false,"legend":{"yanchor":"top","y":0.5}},"source":"A","config":{"modeBarButtonsToAdd":[{"name":"Collaborate","icon":{"width":1000,"ascent":500,"descent":-50,"path":"M487 375c7-10 9-23 5-36l-79-259c-3-12-11-23-22-31-11-8-22-12-35-12l-263 0c-15 0-29 5-43 15-13 10-23 23-28 37-5 13-5 25-1 37 0 0 0 3 1 7 1 5 1 8 1 11 0 2 0 4-1 6 0 3-1 5-1 6 1 2 2 4 3 6 1 2 2 4 4 6 2 3 4 5 5 7 5 7 9 16 13 26 4 10 7 19 9 26 0 2 0 5 0 9-1 4-1 6 0 8 0 2 2 5 4 8 3 3 5 5 5 7 4 6 8 15 12 26 4 11 7 19 7 26 1 1 0 4 0 9-1 4-1 7 0 8 1 2 3 5 6 8 4 4 6 6 6 7 4 5 8 13 13 24 4 11 7 20 7 28 1 1 0 4 0 7-1 3-1 6-1 7 0 2 1 4 3 6 1 1 3 4 5 6 2 3 3 5 5 6 1 2 3 5 4 9 2 3 3 7 5 10 1 3 2 6 4 10 2 4 4 7 6 9 2 3 4 5 7 7 3 2 7 3 11 3 3 0 8 0 13-1l0-1c7 2 12 2 14 2l218 0c14 0 25-5 32-16 8-10 10-23 6-37l-79-259c-7-22-13-37-20-43-7-7-19-10-37-10l-248 0c-5 0-9-2-11-5-2-3-2-7 0-12 4-13 18-20 41-20l264 0c5 0 10 2 16 5 5 3 8 6 10 11l85 282c2 5 2 10 2 17 7-3 13-7 17-13z m-304 0c-1-3-1-5 0-7 1-1 3-2 6-2l174 0c2 0 4 1 7 2 2 2 4 4 5 7l6 18c0 3 0 5-1 7-1 1-3 2-6 2l-173 0c-3 0-5-1-8-2-2-2-4-4-4-7z m-24-73c-1-3-1-5 0-7 2-2 3-2 6-2l174 0c2 0 5 0 7 2 3 2 4 4 5 7l6 18c1 2 0 5-1 6-1 2-3 3-5 3l-174 0c-3 0-5-1-7-3-3-1-4-4-5-6z"},"click":"function(gd) { \n        // is this being viewed in RStudio?\n        if (location.search == '?viewer_pane=1') {\n          alert('To learn about plotly for collaboration, visit:\\n https://cpsievert.github.io/plotly_book/plot-ly-for-collaboration.html');\n        } else {\n          window.open('https://cpsievert.github.io/plotly_book/plot-ly-for-collaboration.html', '_blank');\n        }\n      }"}],"cloud":false},"data":[{"x":[-1.21676782852413,-0.38484191973245,-0.0020275124657424,0.0781493418518983,-1.52345845797746,-0.628913147775892,1.03055869446875,-0.837417985654862,-0.108193353708965,0.197539248769764,-0.349681357985816,0.995507406545255,-0.425666597241691,-0.154129602988335,-0.340977109284144,0.121327993928005,1.54791971871385,0.331959631200392,2.55684543403503,0.922559805334119,-0.337118664811867,0.0467468756585474,1.63647535077002,1.90009106225772,0.00487976520108421,0.629436010744478,-1.08090242660371,-0.357373519163967,-0.225527381436878,0.385500933546647,0.856195301163185,-0.0945153379180547,-0.753861436940349,-0.224580254449715,0.411488138305488,-0.566160247325228,-1.1080000377738,-0.463585049370458,0.522833648083796,-0.375531438487688,1.33372758861475,-0.566799027557544,0.623190822240257,0.739566671591614,-2.2824071690723,0.597413823261678,-1.55055009656926,-1.86966183907347,-0.186402259331083,-0.957986553716378,1.83048017841204,0.111774256841093,-0.755366749258637,0.790707708859392,-0.575497921425891,1.40329450066308,0.720383437138196,0.875735961195073,-1.79013884592312,-1.04972043073113,1.35706970771101,-0.872257894850014,-0.228867738323889,-0.478411526313821,0.0469078315547106,-0.337301463010518,0.246630379575189,-0.215336135649148,1.26172787759811,-0.778210922727769,-2.11430117652017,1.72101466471965,-0.369121475315158,-0.295907970754035,0.622300523630637,-0.437270244051458,0.905401611597984,-0.0412487429285033,1.69124662684021,0.398440404481885,-1.01264318817656,-1.55792377567185,-0.634363408940658,0.793485457964339,0.653982802169777,-0.67886921762861,0.676985197721527,-1.72696246889524,0.42417601894265,0.634623231687356,0.163338365650428,-0.117100872853722,-1.20457036400508,1.27447848966301,-0.267396456320821,-1.0158120696569,0.198718713587252,-1.45618258505497,0.156156082813403,0.341763979124765],"y":[0.680860463076144,-0.72895133161784,1.27079952303301,-1.65648652334842,-2.1997620410698,-0.0274227444916557,-0.44984602298204,-0.571103294467408,1.34436578388758,-1.91751496147806,0.0471069752267473,-0.415539945109513,1.05191385377258,1.0207701985957,-0.504330091549893,1.88126869738222,1.68373065346992,0.92868870104302,0.870330468888661,-0.531849794975228,1.85216643107376,-0.585619076792819,0.912069259516836,-0.210828740638127,1.10497175042178,-1.06995254896798,0.715586641912111,1.25493795329225,-0.24218861062899,0.193598659229884,-1.26583288436644,0.498852761738408,-1.57856913701808,0.295629578239337,0.0626245982168598,-1.41475444916284,0.725135039682719,-0.186115140627056,-1.79977695906214,0.162781136745989,0.583584295720104,0.0367209086227595,-0.348755237179466,0.372059252289536,-0.242409084317031,0.416893234251502,-0.619241313972935,-0.319959127772434,-1.42679026138185,-2.51629016449042,0.506256006409368,2.21215670681565,0.864805072111069,-2.29830660164053,-0.564012973093804,0.815154060475146,-0.483629547554301,-1.8100174987364,-0.374632974900898,0.622877664992162,0.784624982097113,0.0753100144051935,1.30980850225651,0.497869353372584,-0.732607713310735,0.551000455058889,0.454460861649889,2.12384811707174,-0.34716489625471,1.1002790870042,0.513760083350593,-0.113553814328086,-1.00369839055116,-2.14910187286822,-0.443329743715982,-0.382787254031646,-1.59005203380693,0.538791316621154,-1.24087808750671,0.197683942603811,-0.292253597798126,-0.0385264053516048,-0.0625601884314694,-0.468961960747959,0.765264386007238,0.321332651767084,-0.39077398432238,-1.39473258416074,0.0418613104902942,-0.573954632546888,0.0471362759462331,0.673753539957118,-0.566698141601014,-0.0444974326882849,0.172876479151388,0.729379247061036,1.90899776206429,1.58083943938756,-0.111490545901197,1.76249661490948],"z":[-5.83783797242898,2.8750728186243,-6.35805264009656,8.43873130044588,7.95189328939408,-1.1207125730935,4.31034750384771,1.18068050102732,-6.93821562685585,9.98265330492984,-0.934897592105369,4.06871453863808,-6.1109024633463,-5.41211019895516,1.83969623918118,-9.16368749905511,-5.32281382992189,-3.97952424281432,0.762038523626751,4.50436858554438,-9.93506948499253,3.02158913528119,-1.28739559604413,4.85432582770608,-5.51509922170674,6.60863476632886,-5.73973806276798,-6.9894368047892,0.759888290271196,-0.196991429056125,8.04155502415855,-2.68329448452815,6.38512281120969,-1.92730840009611,0.509853285526677,5.94145175116373,-5.8416752739612,0.00340560439436544,10.0445520914783,-1.56496856070532,-0.250466301371028,-1.31720259822889,2.99015783037784,-0.38116291826445,-3.35276891655945,-0.889638524734157,-0.00489362327384857,-2.13952803928477,6.76114678824707,10.6654777150193,1.12968032477724,-10.8372350203961,-5.83475885907262,13.0729484259214,1.66906902261724,-1.26918130104956,3.8589146120479,10.8015594160721,-1.70711281734174,-5.21382918642308,-1.20898549506355,-2.121065861726,-7.00677798793032,-3.44616981949056,3.7568542296631,-3.42960520131548,-1.77904354909906,-11.049912856657,4.25928023646977,-7.05781728047655,-6.79740276979331,4.00979840107973,4.28024900212548,10.153693422833,3.46124976584118,1.03939578205532,9.76106339223062,-2.77645406896278,9.58688369121398,-0.191538904055286,-0.564018387362491,-2.92321552458568,-0.955925875723969,3.93178071966848,-2.51835632569664,-2.96440169409264,3.30784031705495,3.51973798301322,0.639045485433829,4.13901962610915,0.0909953515696913,-3.60296944549303,0.424349979994913,2.77144414276744,-1.39917530839858,-5.67852037461898,-9.14755138314696,-10.8165623670477,0.869764895132789,-8.12895511629788],"type":"scatter3d","mode":"markers","marker":{"color":"rgba(31,119,180,1)","size":[55],"sizemode":"area","line":{"color":"rgba(31,119,180,1)"}},"textfont":{"size":55},"error_y":{"color":"rgba(31,119,180,1)","width":55},"error_x":{"color":"rgba(31,119,180,1)","width":55},"line":{"color":"rgba(31,119,180,1)","width":55},"frame":null},{"colorbar":{"title":"z<br />z","ticklen":2,"len":0.5,"lenmode":"fraction","y":1,"yanchor":"top"},"colorscale":[["0","rgba(68,1,84,1)"],["0.0782760531585063","rgba(72,31,109,1)"],["0.167785658471411","rgba(68,58,129,1)"],["0.198340548278871","rgba(65,67,133,1)"],["0.218160869645152","rgba(63,73,136,1)"],["0.236025603333364","rgba(61,78,138,1)"],["0.313583991635724","rgba(52,99,141,1)"],["0.336674367345814","rgba(49,105,142,1)"],["0.369375121507966","rgba(47,112,142,1)"],["0.388037221693722","rgba(45,117,142,1)"],["0.404888571050868","rgba(44,121,142,1)"],["0.418767594314592","rgba(42,124,142,1)"],["0.444976162698885","rgba(38,130,142,1)"],["0.45808024683441","rgba(38,133,141,1)"],["0.483220466907567","rgba(37,140,140,1)"],["0.50027667267492","rgba(37,144,140,1)"],["0.534331684158341","rgba(34,153,138,1)"],["0.584809704968465","rgba(39,165,133,1)"],["0.614864132748141","rgba(45,171,129,1)"],["0.627827338792287","rgba(47,174,127,1)"],["0.640772697744454","rgba(49,177,125,1)"],["0.728550831260994","rgba(89,195,104,1)"],["0.803774886440775","rgba(128,209,81,1)"],["0.874138741370851","rgba(172,220,52,1)"],["1","rgba(253,231,37,1)"]],"showscale":true,"x":[-1.21676782852413,-0.38484191973245,-0.0020275124657424,0.0781493418518983,-1.52345845797746,-0.628913147775892,1.03055869446875,-0.837417985654862,-0.108193353708965,0.197539248769764,-0.349681357985816,0.995507406545255,-0.425666597241691,-0.154129602988335,-0.340977109284144,0.121327993928005,1.54791971871385,0.331959631200392,2.55684543403503,0.922559805334119,-0.337118664811867,0.0467468756585474,1.63647535077002,1.90009106225772,0.00487976520108421,0.629436010744478,-1.08090242660371,-0.357373519163967,-0.225527381436878,0.385500933546647,0.856195301163185,-0.0945153379180547,-0.753861436940349,-0.224580254449715,0.411488138305488,-0.566160247325228,-1.1080000377738,-0.463585049370458,0.522833648083796,-0.375531438487688,1.33372758861475,-0.566799027557544,0.623190822240257,0.739566671591614,-2.2824071690723,0.597413823261678,-1.55055009656926,-1.86966183907347,-0.186402259331083,-0.957986553716378,1.83048017841204,0.111774256841093,-0.755366749258637,0.790707708859392,-0.575497921425891,1.40329450066308,0.720383437138196,0.875735961195073,-1.79013884592312,-1.04972043073113,1.35706970771101,-0.872257894850014,-0.228867738323889,-0.478411526313821,0.0469078315547106,-0.337301463010518,0.246630379575189,-0.215336135649148,1.26172787759811,-0.778210922727769,-2.11430117652017,1.72101466471965,-0.369121475315158,-0.295907970754035,0.622300523630637,-0.437270244051458,0.905401611597984,-0.0412487429285033,1.69124662684021,0.398440404481885,-1.01264318817656,-1.55792377567185,-0.634363408940658,0.793485457964339,0.653982802169777,-0.67886921762861,0.676985197721527,-1.72696246889524,0.42417601894265,0.634623231687356,0.163338365650428,-0.117100872853722,-1.20457036400508,1.27447848966301,-0.267396456320821,-1.0158120696569,0.198718713587252,-1.45618258505497,0.156156082813403,0.341763979124765],"y":[0.680860463076144,-0.72895133161784,1.27079952303301,-1.65648652334842,-2.1997620410698,-0.0274227444916557,-0.44984602298204,-0.571103294467408,1.34436578388758,-1.91751496147806,0.0471069752267473,-0.415539945109513,1.05191385377258,1.0207701985957,-0.504330091549893,1.88126869738222,1.68373065346992,0.92868870104302,0.870330468888661,-0.531849794975228,1.85216643107376,-0.585619076792819,0.912069259516836,-0.210828740638127,1.10497175042178,-1.06995254896798,0.715586641912111,1.25493795329225,-0.24218861062899,0.193598659229884,-1.26583288436644,0.498852761738408,-1.57856913701808,0.295629578239337,0.0626245982168598,-1.41475444916284,0.725135039682719,-0.186115140627056,-1.79977695906214,0.162781136745989,0.583584295720104,0.0367209086227595,-0.348755237179466,0.372059252289536,-0.242409084317031,0.416893234251502,-0.619241313972935,-0.319959127772434,-1.42679026138185,-2.51629016449042,0.506256006409368,2.21215670681565,0.864805072111069,-2.29830660164053,-0.564012973093804,0.815154060475146,-0.483629547554301,-1.8100174987364,-0.374632974900898,0.622877664992162,0.784624982097113,0.0753100144051935,1.30980850225651,0.497869353372584,-0.732607713310735,0.551000455058889,0.454460861649889,2.12384811707174,-0.34716489625471,1.1002790870042,0.513760083350593,-0.113553814328086,-1.00369839055116,-2.14910187286822,-0.443329743715982,-0.382787254031646,-1.59005203380693,0.538791316621154,-1.24087808750671,0.197683942603811,-0.292253597798126,-0.0385264053516048,-0.0625601884314694,-0.468961960747959,0.765264386007238,0.321332651767084,-0.39077398432238,-1.39473258416074,0.0418613104902942,-0.573954632546888,0.0471362759462331,0.673753539957118,-0.566698141601014,-0.0444974326882849,0.172876479151388,0.729379247061036,1.90899776206429,1.58083943938756,-0.111490545901197,1.76249661490948],"z":[-5.83783797242898,2.8750728186243,-6.35805264009656,8.43873130044588,7.95189328939408,-1.1207125730935,4.31034750384771,1.18068050102732,-6.93821562685585,9.98265330492984,-0.934897592105369,4.06871453863808,-6.1109024633463,-5.41211019895516,1.83969623918118,-9.16368749905511,-5.32281382992189,-3.97952424281432,0.762038523626751,4.50436858554438,-9.93506948499253,3.02158913528119,-1.28739559604413,4.85432582770608,-5.51509922170674,6.60863476632886,-5.73973806276798,-6.9894368047892,0.759888290271196,-0.196991429056125,8.04155502415855,-2.68329448452815,6.38512281120969,-1.92730840009611,0.509853285526677,5.94145175116373,-5.8416752739612,0.00340560439436544,10.0445520914783,-1.56496856070532,-0.250466301371028,-1.31720259822889,2.99015783037784,-0.38116291826445,-3.35276891655945,-0.889638524734157,-0.00489362327384857,-2.13952803928477,6.76114678824707,10.6654777150193,1.12968032477724,-10.8372350203961,-5.83475885907262,13.0729484259214,1.66906902261724,-1.26918130104956,3.8589146120479,10.8015594160721,-1.70711281734174,-5.21382918642308,-1.20898549506355,-2.121065861726,-7.00677798793032,-3.44616981949056,3.7568542296631,-3.42960520131548,-1.77904354909906,-11.049912856657,4.25928023646977,-7.05781728047655,-6.79740276979331,4.00979840107973,4.28024900212548,10.153693422833,3.46124976584118,1.03939578205532,9.76106339223062,-2.77645406896278,9.58688369121398,-0.191538904055286,-0.564018387362491,-2.92321552458568,-0.955925875723969,3.93178071966848,-2.51835632569664,-2.96440169409264,3.30784031705495,3.51973798301322,0.639045485433829,4.13901962610915,0.0909953515696913,-3.60296944549303,0.424349979994913,2.77144414276744,-1.39917530839858,-5.67852037461898,-9.14755138314696,-10.8165623670477,0.869764895132789,-8.12895511629788],"type":"mesh3d","opacity":0.3,"frame":null}],"highlight":{"on":"plotly_click","persistent":false,"dynamic":false,"selectize":false,"opacityDim":0.2,"selected":{"opacity":1},"debounce":0},"base_url":"https://plot.ly"},"evals":["config.modeBarButtonsToAdd.0.click"],"jsHooks":[]}</script>
<p>Il est rare que des variables soient parfaitement collinéaires, donc la réduction de la dimensionnalité sera toujours associée à une perte d’information; le but de l’ordination est de choisir judicieusement les nouveaux axes afin de minimiser la variation des données dans les dimensions qui seront éliminées, ou de façon équivalente, maximiser la variation “expliquée” par les axes retenus.</p>
</div>
<div id="fonctionnement-de-lanalyse-en-composantes-principales" class="section level2">
<h2>Fonctionnement de l’analyse en composantes principales</h2>
<p>Prenons un jeu de données multivariées <span class="math inline">\(X\)</span>, soit une matrice de <span class="math inline">\(n\)</span> observations de <span class="math inline">\(p\)</span> variables et supposons que ces variables aient été préalablement normalisées. L’analyse en composantes principales (ACP) est une transformation linéaire de la matrice <span class="math inline">\(X\)</span> (équivalente à une rotation en <span class="math inline">\(p\)</span> dimensions) déterminée de la manière suivante:</p>
<ul>
<li>le premier axe (première nouvelle variable) est choisi de façon à maximiser la variance des données le long de cet axe;</li>
<li>le deuxième axe est choisi de façon à maximiser la variance des données à condition d’être orthogonal (perpendiculaire) au premier axe;</li>
<li>le troisème axe est choisi de façon à maximiser la variance des données à condition d’être orthogonal aux deux précédents;</li>
<li>et ainsi de suite.</li>
</ul>
<p>Les variables transformées, ou composantes principales, obtenues par l’ACP ont donc la propriété d’être orthognales les unes aux autres (ce qui signifie en particulier que leur corrélation est de 0) et d’être classées en ordre décroissant de variance expliquée.</p>
<p>Mathématiquement, l’ACP requiert le calcul des valeurs propres et les vecteurs propres de la matrice de covariance de <span class="math inline">\(X\)</span>, <span class="math inline">\(C_X\)</span>. Un élément de cette matrice, <span class="math inline">\(C_{X ~ i,j}\)</span>, correspond à la covariance entre les colonnes (variables) <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span> de <span class="math inline">\(X\)</span>. Les vecteurs propres indiquent la direction des composantes principales tandis que les valeurs propres indiquent la variance des données selon chaque composante principale.</p>
<p>Le développement de l’ACP est basé sur la théorie des distributions normales multivariées et la méthode s’applique mieux lorsque les variables s’approchent de la normalité. En pratique, il suffit de transformer les variables très asymétriques afin d’éviter que certaines valeurs extrêmes n’aient une influence trop grande sur l’analyse.</p>
<p>Nous verrons au prochain cours des méthodes d’ordination adaptées aux données de présence-absence et d’abondance communes en écologie.</p>
</div>
<div id="acp-avec-r" class="section level2">
<h2>ACP avec R</h2>
<p>Il existe plusieurs fonctions pour effectuer une ACP dans R. Dans ce cours, nous utiliserons la fonction <code>prcomp</code>.</p>
<p><strong>Note</strong>: Si on n’avait pas normalisé les variables au préalable, nous pouvons le faire directement dans la fonction <code>prcomp</code> avec l’argument <code>scale. = TRUE</code>.</p>
<pre class="r"><code>clim_acp &lt;- prcomp(clim_norm)
summary(clim_acp)</code></pre>
<pre><code>## Importance of components:
##                           PC1    PC2    PC3     PC4     PC5     PC6
## Standard deviation     1.9785 1.5741 0.9774 0.90767 0.75003 0.46655
## Proportion of Variance 0.4349 0.2753 0.1061 0.09154 0.06251 0.02418
## Cumulative Proportion  0.4349 0.7102 0.8164 0.90792 0.97042 0.99461
##                            PC7     PC8     PC9
## Standard deviation     0.20003 0.08141 0.04355
## Proportion of Variance 0.00445 0.00074 0.00021
## Cumulative Proportion  0.99905 0.99979 1.00000</code></pre>
<p>Le sommaire du résultat de l’ACP indique d’abord l’écart-type de chacune des 9 composantes principales (rotation des variables originales). Ces valeurs sont aussi enregistrées dans l’élément <code>sdev</code> du résultat (<code>clim_acp$sdev</code>). Les deux rangées suivantes indiquent le rapport entre la variance d’une composante et la variance totale (somme des variances des 9 variables), puis la proportion cumulative.</p>
<p>Les variances associées à chaque composante principale peuvent être visualiées avec la fonction <code>screeplot</code>.</p>
<pre class="r"><code>screeplot(clim_acp)</code></pre>
<p><img src="13-Analyses_multivariees_Partie1_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p>La transformation entre les variables originales (normalisées) et les composantes principales est donnée par l’élément <code>rotation</code>.</p>
<pre class="r"><code>round(clim_acp$rotation, 2)</code></pre>
<pre><code>##          PC1   PC2   PC3   PC4   PC5   PC6   PC7   PC8   PC9
## t_mean  0.47 -0.11  0.11 -0.27  0.19 -0.01  0.08  0.80  0.03
## t_diu  -0.09 -0.46  0.05 -0.35 -0.78  0.06 -0.06  0.07 -0.19
## t_sd   -0.38 -0.16 -0.58 -0.08  0.30  0.00 -0.01  0.20 -0.60
## t_max   0.27 -0.37 -0.33 -0.51  0.30  0.21 -0.06 -0.41  0.34
## t_min   0.46  0.07  0.36 -0.12  0.13  0.03 -0.18 -0.34 -0.69
## p_ann   0.33  0.37 -0.39 -0.01 -0.29  0.24  0.66 -0.08 -0.11
## p_max   0.39  0.15 -0.48  0.30 -0.25  0.00 -0.66  0.08  0.06
## p_min  -0.09  0.49 -0.09 -0.57 -0.08 -0.63 -0.10 -0.04  0.04
## p_cv    0.27 -0.45 -0.13  0.33  0.00 -0.71  0.29 -0.14 -0.02</code></pre>
<p>Par exemple, la première colonne de cette matrice nous indique que la composante principale est calculée par l’équation:</p>
<p><span class="math display">\[ PC1 = 0.47 T_{mean} - 0.09 T_{diu} - 0.38 T_{sd} + 0.27 T_{max} + 0.46 T_{min} + 
0.33 P_{ann} + 0.39 P_{max} - 0.09 P_{min} + 0.27 P_{cv} \]</span></p>
<p>Puisque les variables ont été normalisées au préalable, la magnitude de ces coefficients indique l’importance de l’association entre une variable et la composante principale donnée, alors que le signe indique la direction de cette association. Dans ce cas-ci:</p>
<ul>
<li><p>la première composante principale est associée entre autres à une température moyenne et une température minimale élevées;</p></li>
<li><p>la deuxième composante est d’abord associée à une précipitation minimale élevée, à une faible variation journalière et à une faible variation de la précipitation.</p></li>
</ul>
<p>Inversement, les rangées de la matrice <code>rotation</code> indiquent comment une augmentation unitaire de chaque variable originale est “décomposée” sur les différents axes des composantes principales.</p>
<p>L’élément <code>x</code> du résultat donne quand à lui les coordonnées de chaque observation sur les axes des composantes principales:</p>
<pre class="r"><code>round(head(clim_acp$x), 2)</code></pre>
<pre><code>##            PC1   PC2   PC3   PC4   PC5   PC6   PC7   PC8   PC9
## Tokyo    -0.83  1.14 -1.07 -0.37  0.48  0.15  0.29 -0.03  0.01
## Shanghai -1.00  0.71 -1.00 -0.30  0.99  0.05  0.04  0.03 -0.01
## Mumbai    4.39  0.53 -2.00  1.97 -0.49 -0.24 -0.58  0.04  0.00
## Karachi   0.80 -2.03  0.81  0.09  1.04 -0.78  0.14  0.20  0.08
## Delhi     1.22 -2.75 -1.11 -0.58  0.05 -0.48 -0.12  0.01  0.06
## Manila    3.30  0.64 -0.51  0.48 -0.02  0.52  0.17 -0.08 -0.06</code></pre>
</div>
<div id="visualisation-de-lacp" class="section level2">
<h2>Visualisation de l’ACP</h2>
<p>Dans la section précédente, nous avons vu que chaque observation est associée à des coordonnées sur les 9 axes de composantes principales. Nous avons aussi vu qu’une augmentation unitaire d’une des variables originales est associée à une variation sur chacun des axes.</p>
<p>Le diagramme de double projection, ou <em>biplot</em>, permet de visualiser simultanément les coordonnées des observations et les vecteurs correspondant aux variables originales dans l’espace des composantes principales. Ce diagramme montre généralement les deux premières composantes qui comptent pour la plus grande partie de la variance totale.</p>
<pre class="r"><code>biplot(clim_acp)</code></pre>
<p><img src="13-Analyses_multivariees_Partie1_files/figure-html/unnamed-chunk-12-1.png" width="576" /></p>
<p>Le diagramme peut nous aider à interpréter les composantes principales. Par exemple:</p>
<ul>
<li><p>Les villes au climat le plus froid (ex.: Saint-Pétersbourg, Montréal) sont concentrées à gauche du graphique, un peu en haut de la médiane, à l’opposé des vecteurs associés à une température minimale, moyenne et maximale plus élevée.</p></li>
<li><p>Les villes situées à droite (ex.: Mumbai, Manille) sont caractérisées par des températures élevées toute l’année (<code>t_min</code> élevée) et beaucoup de précipitation lors du mois le plus humide (<code>p_max</code> élevée).</p></li>
<li><p>La ville de Singapour est placée à part des autres, notamment en raison de ses fortes pluies toute l’année (<code>p_ann</code> et <code>p_min</code> élevées).</p></li>
<li><p>Les villes en bas du graphique ont une température maximale élevée, au moins une saison très aride (<code>p_min</code> faible) et une grande variation de température journalière.</p></li>
</ul>
<p>Puisque les deux premières composantes n’expliquent que 70% de la variance totale, il faut s’attendre à ce qu’elles ne représentent pas parfaitement la “distance” climatique entre les villes. Par exemple, la ville avec les précipitations annuelles les plus faibles (Lima) se trouve au centre du graphique plutôt qu’à proximité des autres climats arides; cela est dû au fait que les variations de température sont moins prononcées dans cette ville.</p>
<p>L’argument <code>choices</code> de <code>biplot</code> permet de visualiser d’autres composantes que les deux premières.</p>
<pre class="r"><code>biplot(clim_acp, choices = c(1, 3))</code></pre>
<p><img src="13-Analyses_multivariees_Partie1_files/figure-html/unnamed-chunk-14-1.png" width="576" /></p>
<p>Pour interpréter la troisième composante principale, nous pouvons nous concentrer sur les deux villes situées aux extrêmes: Séoul et Lima se retrouvaient toutes deux près du centre du graphique des composantes 1 et 2. Dans ce graphique-là, la variation de température (<code>t_sd</code>) et la quantité de précipitation (<code>p_ann</code> et <code>p_max</code>) pointaient dans des directions opposées, parce que généralement, la température varie moins dans les villes avec des précipitations plus abondantes. Sur la troisième composante principale, ces deux variables sont associées à des valeurs négatives, donc cette composante permet de contraster les villes avec de fortes précipitations et une grande variation de température (Séoul) des villes avec de faibles précipitation et une faible variation de température (Lima).</p>
</div>
<div id="combien-de-composantes-principales-choisir" class="section level2">
<h2>Combien de composantes principales choisir?</h2>
<p>Différents critères ont été proposés pour déterminer combien de composantes principales suffisent à décrire des données muiltivariées. Autrement dit, quelles composantes principales comptent pour une portion suffisamment importante de la variance totale?</p>
<p>Voici les variances (carré des écarts-types) associées aux composantes principales dans notre exemple:</p>
<pre class="r"><code>clim_acp$sdev^2</code></pre>
<pre><code>## [1] 3.914417064 2.477765395 0.955214474 0.823859308 0.562545790 0.217664459
## [7] 0.040010038 0.006626862 0.001896610</code></pre>
<p>Pour des données normalisées, la somme des variances est toujours égale au nombre de variables (ici, 9) et la moyenne des variances est donc de 1. Un des critères les plus simples propose donc de conserver les composantes avec une variance supérieure à 1. Toutefois, si l’ensemble des variances sont proches de 1, cela signifierait que les variables originales sont presque indépendantes, donc que l’ACP n’est pas très utile.</p>
<p>D’autres critères sont basés sur des tests statistiques plus précis, tels que ceux évalués dans l’article de Peres-Neto et al. (2005)</p>
<p>En pratique, des tests d’hypothèse formels sont rarement nécessaires. Pour une analyse de données exploratoire, on visualise toujours les deux premières composantes, puis on peut inspecter les suivantes si elles contribuent à une portion jugée non négligeable de la variance et qu’elles sont facilement interprétables. Pour l’utilisation des composantes principales dans une régression (voir ci-dessous), les méthodes de sélection de modèles peuvent nous guider sur le nombre de composantes principales à conserver dans la régression elle-même.</p>
</div>
<div id="acp-et-regression" class="section level2">
<h2>ACP et régression</h2>
<p>Tel que mentionné plus haut, il est difficile d’estimer les paramètres d’une régression si les prédicteurs potentiels sont nombreux et corrélés. En transformant ces prédicteurs en un nombre plus réduit de variables non-corrélées, l’ACP peut résoudre ces deux problèmes.</p>
<p>Le principal inconvénient à cette approche (ACP suivie d’une régression en fonction des composantes principales) est que les effets sont généralement plus difficiles à interpréter en fonction des variables originales, surtout si plusieurs variables contribuent de façon substantielle à chaque axe.</p>
<p>Dans certaines études, le but principal est de prédire la réponse et on s’intéresse peu à l’effet des prédicteurs individuels. Par exemple, considérons un projet visant à identifier les espèces dominantes d’une forêt à partir d’images de télédétection hyperspectrales contenant des données de réflectance pour des centaines de longueurs d’onde. Dans ce cas, les méthodes multivariées comme l’ACP sont utilisées pour réduire ce spectre de réflectance en un plus petit nombre de composantes orthogonales.</p>
</div>
</div>
<div id="classification-hierarchique-ascendante" class="section level1">
<h1>Classification hiérarchique ascendante</h1>
<p>La classification hiérarchique ascendante vise à créer des groupes d’observations semblables selon une série de variables. Ce nom vient du fait qu’on commence avec les observations individuelles, qui sont regroupées progressivement jusqu’à ce qu’on obtienne un seul groupe. La structure résultante est un arbre ou <em>dendrogramme</em> montrant les relations de proximité pour l’ensemble des observations.</p>
<div id="matrice-de-distance" class="section level2">
<h2>Matrice de distance</h2>
<p>L’algorithme de classification hiérarchique requiert une matrice de la distance <span class="math inline">\(d_{ij}\)</span> pour chaque paire d’observations <span class="math inline">\(i\)</span> et <span class="math inline">\(j\)</span>.</p>
<p><span class="math display">\[  
\begin{bmatrix}
0 \\
d_{21} &amp; 0  \\
d_{31} &amp; d_{32} &amp; 0 \\
... \\
d_{n1} &amp; d_{n2} &amp; ... &amp; d_{n(n-1)} &amp; 0
\end{bmatrix}
\]</span></p>
<p>Il s’agit d’une matrice <span class="math inline">\(n \times n\)</span> où toutes les valeurs diagonales sont zéro (chaque observation est à une distance 0 d’elle-même). Puisque la matrice est symétrique (<span class="math inline">\(d_{ji}\)</span> = <span class="math inline">\(d_{ij}\)</span>), on peut omettre les valeurs du triangle supérieur dans la représentation.</p>
<p>Pour des variables numériques, la distance la plus couramment utilisée est la <em>distance euclidienne</em>, calculée ainsi:</p>
<p><span class="math display">\[ d_{ij} = \sqrt{\sum_{k = 1}^p (x_{ik} - x_{jk})^2} \]</span></p>
<p>En deux dimensions et avec les variables <span class="math inline">\(x\)</span> et <span class="math inline">\(y\)</span> au lieu de <span class="math inline">\(x_1\)</span> et <span class="math inline">\(x_2\)</span>, cette formule se simplifie à:</p>
<p><span class="math display">\[  d_{ij} = \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2} \]</span></p>
<p>Il s’agit de la distance en ligne droite entre les deux points calculées à partir du théorème de Pythagore. La fonction ci-dessus est donc la généralisation de cette distance à <span class="math inline">\(p\)</span> dimensions.</p>
<p>Dans R, la fonction <code>dist</code> calcule la matrice de distance entre les rangées d’une matrice de données numériques. Cette fonction utilise la distance euclidienne par défaut.</p>
<p>Comme dans le cas de l’ACP, il est recommandé de normaliser les variables avant de calculer la matrice de distance, afin de les placer sur une échelle comparable.</p>
</div>
<div id="algorithme-de-classification-hierarchique-ascendante" class="section level2">
<h2>Algorithme de classification hiérarchique ascendante</h2>
<p>Supposons qu’on ait la matrice de distance suivante entre 4 observations.</p>
<p><span class="math display">\[
\begin{array}
&amp;&amp; A &amp; B &amp; C \\
B &amp; 11 \\
C &amp; 13 &amp; 6 \\ 
D &amp; 7 &amp; 11 &amp; 9 
\end{array}
\]</span></p>
<ol style="list-style-type: decimal">
<li><p>L’algorithme regroupe d’abord les deux observations les plus rapprochées, soit B et C (distance de 6).</p></li>
<li><p>Ensuite, il remplace B et C par une observation BC et calcule la distance entre ce groupe et chacune des autres observations existantes.</p></li>
</ol>
<p>Comment détermine-t-on la distance du nouveau groupe à partir des distances précédentes? Différentes règles sont possibles. Pour l’instant, utilisons une règle où la distance d’un nouveau groupe à une observation existante est la moyenne des distances entre chaque membre du groupe et l’observation.</p>
<p><span class="math display">\[
\begin{array}
&amp; &amp; A &amp; BC \\
BC &amp; 12 &amp; \\
D &amp; 7 &amp; 10 
\end{array}
\]</span></p>
<ol start="3" style="list-style-type: decimal">
<li>À partir de ce moment, le nouveau groupe (BC) est traité comme une observation individuelle. Il suffit ensuite de répéter les étapes 1 et 2 jusqu’à ce qu’il n’y ait que deux groupes, qui sont joints à la dernière étape.</li>
</ol>
<p>Dans l’exemple, la prochaine étape serait de regrouper A et D (distance de 7). Finalement, on joint AD et BC à une distance de 11 (moyenne de 10 et 12).</p>
</div>
<div id="classification-hierarchique-avec-r" class="section level2">
<h2>Classification hiérarchique avec R</h2>
<p>La fonction <code>hclust</code> permet d’effectuer une classification hiérarchique ascendante. Voici la classification pour le tableau de 9 variables climatiques pour 49 grandes villes. Nous calculons d’abord la matrice de distance, puis effectuons le regroupement avec la méthode “average” (les différentes méthodes seront présentées plus loin).</p>
<pre class="r"><code>clim_dist &lt;- dist(clim_norm)
clim_ch &lt;- hclust(clim_dist, method = &quot;average&quot;)
plot(clim_ch)</code></pre>
<p><img src="13-Analyses_multivariees_Partie1_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>Les “feuilles” au bas du dendrogramme correspondent aux observations individuelles. Une ligne horizontale représente le regroupement de deux observations ou groupes existants. L’échelle à gauche du dendrogramme (<code>Height</code>) indique la distance correspondant à chaque regroupement. Plus la distance augmente, plus le nombre de groupes diminue et la taille des groupes augmentent.</p>
<p>L’argument <code>method</code> indique comment calculer la distance entre groupes:</p>
<ul>
<li><p>saut minimum (<code>method = "single"</code>): la distance entre deux groupes A et B correspond à la distance minimale entre une observation dans A et une observation dans B.</p></li>
<li><p>saut maximum (<code>method = "complete"</code>): la distance entre A et B correspond à la distance maximale entre une observation dans A et une observation dans B.</p></li>
<li><p>lien moyen (<code>method = "average"</code>): la distance entre A et B correspond à la moyenne des distances sur l’ensemble des paires d’observations dont une est dans A et une dans B (il s’agit de la méthode illustrée dans l’exemple précédent).</p></li>
<li><p>la critère de Ward (<code>method = "ward.D2"</code>) consiste à effectuer le regroupement qui minimise l’augmentation de la variance totale intra-groupe.</p></li>
</ul>
<p>Contrastons d’abord les résultats du saut minimum et du saut maximum:</p>
<pre class="r"><code>clim_ch_min &lt;- hclust(clim_dist, method = &quot;single&quot;)
plot(clim_ch_min)</code></pre>
<p><img src="13-Analyses_multivariees_Partie1_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<pre class="r"><code>clim_ch_max &lt;- hclust(clim_dist, method = &quot;complete&quot;)
plot(clim_ch_max)</code></pre>
<p><img src="13-Analyses_multivariees_Partie1_files/figure-html/unnamed-chunk-17-2.png" width="672" /></p>
<p>Pour le critère du saut minimum, plus un groupe contient d’observations, plus il se rapproche potentiellement des autres groupes et observations individuelles, puisque la distance est basée sur l’observation la plus proche parmi toutes celles du groupe. C’est pourquoi cette méthode a tendance a créer des grands groupes auxquelles les observations se joignent une à la fois. La situation inverse se produit pour le saut maximum: plus un groupe est grand, plus il s’éloigne potentiellement des autres groupes et observations. C’est pourquoi cette méthode a tendance à créer des petits groupes d’abord avant de faire grandir les plus grands groupes. Le lien moyen est un compromis entre ces deux extrêmes.</p>
<p>La méthode de Ward est différente puisqu’il s’agit de minimiser la variance entre observations d’un même groupe. Toutefois, puisque l’ajout d’une seule observation éloignée des autres risque d’avoir un grand effet sur la variance, cette méthode tend comme celle du saut maximum à privilégier des plus petits groupes initialement. Ces deux méthodes permettent donc de créer des groupes plus compacts et équilibrés.</p>
<pre class="r"><code>clim_ch_ward &lt;- hclust(clim_dist, method = &quot;ward.D2&quot;)
plot(clim_ch_ward)</code></pre>
<p><img src="13-Analyses_multivariees_Partie1_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
</div>
<div id="extraire-des-groupes-dune-classification-hierarchique" class="section level2">
<h2>Extraire des groupes d’une classification hiérarchique</h2>
<p>La classification hiérarchique définit un nombre différent de groupes le long du dendrogramme. La fonction <code>cutree</code> permet de “couper” le dendrogramme (1) à une certaine hauteur en spécifiant l’argument <em>h</em> ou (2) pour obtenir un certain nombre de groupes en spécifiant l’argument <em>k</em>. Cette fonction renvoie un vecteur indiquant l’indice du groupe correspondant à chaque observation, dans le même ordre que la matrice de données.</p>
<p>Utilisons donc cette méthode pour extraire les trois grands groupes du dernier dendrogramme (critère de Ward):</p>
<pre class="r"><code>groupes &lt;- cutree(clim_ch_ward, k = 3)
head(groupes)</code></pre>
<pre><code>##    Tokyo Shanghai   Mumbai  Karachi    Delhi   Manila 
##        1        1        2        3        3        2</code></pre>
</div>
<div id="comparer-les-groupes-a-lordination" class="section level2">
<h2>Comparer les groupes à l’ordination</h2>
<p>Nous allons finalement représenter les groupes obtenus par classification hiérarchique sur le graphique des deux premiers axes de l’ACP. Tout d’abord, nous créons un nouveau tableau en rattachant les deux premières composantes principales et le vecteur des indices de groupes, qui doit être spécifié comme facteur.</p>
<pre class="r"><code>ord_groupes &lt;- data.frame(clim_acp$x[, 1:2], groupe_ward = as.factor(groupes))
head(ord_groupes)</code></pre>
<pre><code>##                 PC1        PC2 groupe_ward
## Tokyo    -0.8292567  1.1390831           1
## Shanghai -0.9964678  0.7094018           1
## Mumbai    4.3904533  0.5328498           2
## Karachi   0.8027417 -2.0305728           3
## Delhi     1.2169313 -2.7525580           3
## Manila    3.2953893  0.6395510           2</code></pre>
<pre class="r"><code>ggplot(ord_groupes, aes(x = PC1, y = PC2, color = groupe_ward)) +
    geom_point() +
    geom_text(aes(label = rownames(ord_groupes)))</code></pre>
<p><img src="13-Analyses_multivariees_Partie1_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>Comparons maintenant avec quatre groupes extraits avec la méthode du saut maximum:</p>
<pre class="r"><code>ord_groupes$groupe_max &lt;- as.factor(cutree(clim_ch_max, k = 4))

ggplot(ord_groupes, aes(x = PC1, y = PC2, color = groupe_max)) +
    geom_point() +
    geom_text(aes(label = rownames(ord_groupes)))</code></pre>
<p><img src="13-Analyses_multivariees_Partie1_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>Outre la décision de placer Singapour dans un groupe à part ou non, les différences entre les deux méthodes se retrouvent surtout aux endroits où les groupes se chevauchent. D’après le graphique, il est assez clair que la distribution des villes le long des axes climatiques est graduelle plutôt que de former quelques groupes bien séparés. Dans ce cas, l’ordination constitue une meilleure façon de condenser l’information sur les différences entre les climats des différentes villes.</p>
</div>
</div>
<div id="resume" class="section level1">
<h1>Résumé</h1>
<ul>
<li><p>Les analyses multivariées servent à décrire et expliquer la distribution conjointe de plusieurs variables.</p></li>
<li><p>Lorsque les variables représentent différentes unités, il est important de les normaliser afin d’obtenir des échelles comparables pour les analyses multivariées.</p></li>
<li><p>L’ordination vise à produire dans un nombre de dimensions réduit (souvent 2) la représentation la plus fidèle possible de la variation entre les observations multivariées.</p></li>
<li><p>L’analyse en composantes principales (ACP) est une méthode d’ordination qui effectue une transformation linéaire (rotation) des variables originales, afin d’obtenir des composantes principales qui sont non-corrélées et classées en ordre décroissant de variance. Les coordonnées des observations et les variables originales peut être représentées simultanément dans l’espace des composantes principales (diagramme de double projection).</p></li>
<li><p>Les méthodes de regroupement visent à classer les observations multivariées dans un petit nombre de groupes d’observations les plus similaires possibles. La classification hiérarchique ascendante effectue un regroupement graduel à partir des observations individuelles et en fonction de différentes règles qui définissent la distance entre groupes. Cette classification produit un dendrogramme.</p></li>
</ul>
</div>
<div id="references" class="section level1">
<h1>Références</h1>
<p><strong>Manuels</strong></p>
<ul>
<li><p>Manly, B.F. et Alberto, J.A.N. (2016) <em>Multivariate statistical methods: a primer</em>. Chapman and Hall/CRC.</p></li>
<li><p>Legendre, P. et Legendre, L. (2012) <em>Numerical Ecology</em>, 3e éd. Elsevier.</p></li>
<li><p>Borcard, D., Gillet, F. et Legendre, P. (2018) <em>Numerical Ecology with R</em>, 2e éd. Springer.</p></li>
</ul>
<p><strong>Web</strong></p>
<ul>
<li>Cours de François Husson sur l’<a href="https://www.youtube.com/watch?v=f7Fxz5bLSw8">analyse en composantes principales</a> et les <a href="https://www.youtube.com/watch?v=SE_4dLh5vXY&amp;list=PLnZgp6epRBbRwGBLnM8GEmcxuQGM0_oIk">méthodes de regroupement</a>.</li>
</ul>
<p>Sur les critères pour choisir un nombre de composantes principales:</p>
<ul>
<li>Peres-Neto, P.R., Jackson, D.A. et Somers, K.M. (2005) “How many principal components? stopping rules for determining the number of non-trivial axes revisited.” <em>Computational Statistics and Data Analysis</em> 49: 974-997.</li>
</ul>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
